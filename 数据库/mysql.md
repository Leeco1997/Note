## Mysql

### :one: 基础知识

### :two: 存储引擎

#### 2.1 各种常用引擎简介

| Feature      | InnoDB   | MyISAM | BDB  | Archive   | NDB  | Memory |
| ------------ | -------- | ------ | ---- | --------- | ---- | ------ |
| 支持事务     | ✔        |        | ✔    |           |      |        |
| 锁的粒度     | Row      | Table  | Page | Row       | Row  | Table  |
| MVCC         | ✔        |        |      | ✔         | ✔    |        |
| 存储限制     | 64TB     | No     | No   | No        | No   | Yes    |
| B树索引      | ✔        | ✔      | ✔    |           | ✔    | ✔      |
| 哈希索引     | ✔        |        |      |           | ✔    | ✔      |
| 全文索引     | ✔(1.2.X) | ✔      |      |           |      |        |
| 集群索引     | **✔**    |        |      |           |      |        |
| 数据缓存     | ✔        |        |      |           |      | ✔      |
| 索引缓存     | ✔        | ✔      |      |           | ✔    | ✔      |
| 数据可压缩   |          | ✔      |      | ✔         |      |        |
| 空间使用     | High     | Low    | Low  | Very  Low | Low  | N/A    |
| 内存使用     | High     | Low    | Low  | Low       | High | Medium |
| 批量插入速度 | Low      | High   | High | Very High | High | High   |
| 支持外键     | ✔        |        |      |           |      |        |

+ innoDB
  1. 支持事务、行锁、支持外键
  2. MVCC 、一致性非锁读定
  3. 插入缓冲、二次写、自适应哈希索引、预读
  4. next-key 避免幻读
  5. 聚集索引
+ myisam
  1. 不支持事务、表锁、全文索引
  2. 只缓存索引
+ memory
  1. 表中的数据存放在`内存`中，所以适合存储临时数据【查询的中间集】
  2. 哈希索引
+ NDB
  1. `share nothing`的集群
  2. 索引数据存放在内存，主键查询速度快
  3. 需要数据库层完成 `join`操作
+ archive  
  1. 数据行压缩后存储，适合存储归档数据，比如日志信息
  2. 只支持`insert`   `select`

#### 2.2 缓冲池

具有多个缓冲池实例。

<img src="E:\CS\cs-note\img\innodb.jpg" style="zoom: 33%;" />

+ Master Thread    负责异步刷新缓冲池的数据到磁盘  `checkPoint` 
+ IO Thread  负责IO的回调（因为innodb使用了很多AIO）
+ Purge Thread       回收undo页
+ Page Cleaner Thread   负责脏页的刷新

**缓冲池的更新**

+ `LRU`    + `midpoint ` + `innodb_old_blocks_time`    最近最少使用

  新读取到的页面，放到midpoint的位置，默认是5/8;防止某些sql操作把热点数据刷出缓存池，比如全表扫描。

  在该 `innodb_old_blocks_time `  时间窗口内可以访问页面,而不将其移到LRU列表的尾巴，防止被刷新出去

+ `checkPoint`

  ​	先写 redo log, 再修改数据库。  `ACID---D`

  什么时候执行？

  1. 保证LRU列表中有100个空闲页
  2. 缓冲池的脏页占用达到75%
  3. Master Thread开启事务后，每秒日志缓冲刷新一次到磁盘

  

+ 重做日志缓冲池什么适合刷新到redo log ？

  1. Master Thread 每秒刷新一次
  2. 事务提交的时候
  3. redo log buffer 剩余小于50%的时候



#### 2.3 插入缓冲

+ insert buffer   `B+ tree`
  非唯一的辅助索引

#### 2.4 doubleCheck

![double write架构.png](https://cdn.jsdelivr.net/gh/clawhub/image/diffuser/blog/19/11/21/b59293f27e6aef0b4749a0339f5332cc.jpg)

1. 将脏页先复制到内存中的doublewrite buffer
2. 通过doublewrite buffer分两次顺序的写入共享表空间的物理磁盘，然后马上调用fsync函数，同步磁盘，避免缓冲写带来的问题。
3. 在完成doublewrite页的写入后，再将doublewrite buffer中的页写入各个表空间文件中。

####  2.5 AIO

​	IO merge(合并IO)

####  2.6  刷新邻近页

​	当刷新一个页的时候，会检测该页所在的区，如果是脏页，一起刷新。

### :three: 索引

#### 3.1 B+树索引 /辅助索引/ 联合索引 /覆盖索引

+ 覆盖索引 - 从辅助索引中就能得到查询记录，不需要每一行的完整信息

  `count(*) `

#### 3.2 hash索引

#### 3.3 全文索引

+ 倒排索引

  {单词：单词所在的文档ID}

   {code : (1:6),(4:8)}


#### 3.4 自适应hash索引

只能适用于等值查询

> use index / force index
>
> select * from table `USE index(a)` where a = 1 
>
> select * from table `force index(a)` where a = 1 

| 红黑树                                                       | B树                                          | B+数                                                        |
| ------------------------------------------------------------ | -------------------------------------------- | ----------------------------------------------------------- |
| B树与红黑树最大的不同在于，B树的结点可以有许多子女，从几个到几千个。 | 除根节点外的每个节点至少有t−1个关键字        | 除根节点外的内部节点，每个节点最多有m个关键字，最少有⌈m/2⌉  |
|                                                              | 每个节点存储data和key                        | 子节点存储索引                                              |
|                                                              | 叶子结点的指针为null                         | 只有叶子节点存储data,而且所有的叶子节点之间增加顺序访问指针 |
|                                                              | 一个节点内如果有x个关键字，则有x+1个孩子指针 | 一个节点内如果有x个关键字，则有x个孩子指针                  |

 ![img](https://img-blog.csdn.net/20170920132729406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1YW56aGUxMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)  

**问1：** **为什么B+树比B树更适合做系统的数据库索引和文件索引** ？

> 一般来说，索引很大，往往以索引文件的形式存储的磁盘上，索引查找时产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的时间复杂度。树高度越小，I/O次数越少。  

1）**B+树的磁盘读写代价更低**
因为B+树内部结点没有存放数据data,索引比较小，可以存放在一个Block里面，避免树形结构不断的向下查询，减少IO的开销。
2）**B+树的查询更加稳定**
<dfsdf>因为非终端结点并不是指向文件内容的结点，仅仅是作为叶子结点的关键字索引，因此所有的关键字查询都会走一条从根节点到叶子结点的路径。即s所有关键字查询的长度是一样的，查询效率稳定。B树的中序遍历过程可能需要跨层，但是B+数不需要。

3） **遍历所有的数据更方便**
B+树只要遍历叶子节点就可以实现整棵树的遍历，而其他的树形结构 要中序遍历才可以访问所有的数据。 

  **B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题**， B+树只要遍历叶子节点就可以实现整棵树的遍历。

4) **B+树支持range-query非常方便，而B树不支持** 。



**问2：B树和红黑树的区别**？

 **平衡树（AVL）**更平衡，结构上更加直观，时间效能针对读取而言更高，**但是维护起来比较麻烦！！！** 

 但是，红黑树通过它规则的设定， **每次插入和删除的平均旋转次数应该是远小于平衡树**，确保了插入和删除的最坏的时间复杂度是O(log N) 。 





### :four: 事务

#### 4.1 ACID

+ 原子性（Atomicity）
  原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
+ 一致性（Consistency）
  事务前后数据的完整性必须保持一致。如果事务执行失败，需要自动回滚到原始状态。
+ 隔离性（Isolation）
  事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。
+ 持久性（Durability）
  持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响

> 事务提交后，使用redo log记录变更，undo log在失败的时候进行回滚，

#### 4.2 事务隔离级别

1. 读未提交 read-uncommited （脏读）
2. 读已提交 read-commited（ **不可重复读侧重于修改，幻读侧重于新增或删除** ）
3. 可重复读
4. 串行化

> 1、事务隔离级别为`读已提交`时，写数据只会`锁行`.
>
> 2、事务隔离级别为`可重复读时`，如果检索条件有索引的时候，默认加锁方式是`next-key` 锁；如果检索条件没有索引，更新数据时会`锁表`。 一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读。
>
> 3、事务隔离级别为`串行化`时，读写数据都会`锁表`
>
> 4、隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。

### :five: 并发

#### 5.1 锁

+ 共享锁

+ 排他锁

  从上级往下加锁，意向锁

+ **死锁**

  多个事务同时争夺锁资源而造成的互相等待现象。

  `解决方案`

  1. 超时回滚
  2. wait-for graph  等待图，如果图出现回路，则是出现了死锁；回滚undo log最小的
     + 锁的信息链表
     + 事务等待的链表

  写个死锁的sql

+ **锁的算法**

  1. Record lock :单个行上的锁

  2. Gap Lock: 锁定范围，但不包括记录本身

  3.  :arrow_down_small:Next-key Lock: Gap lock + Record Lock

     如果查询的列是唯一索引，则直接使用 record lock


#### 5.2 MVCC

+ 一致性非锁定读

  ​	读取的时候，不会等待锁的释放。直接读取该数据的一个快照，使用undo log实现。

> 一个数据行可能有多个快照。不同的事务隔离级别，使用规则不同。MVCC技术解决该问题。

+ 显示加锁    `for update/lock in share mode`

#### 5.3 自增长

自增长的列必须是索引，而且必须是索引的第一列。

+ AUTO-INC Locking 

  完成对自增长的sql语句后释放锁，而不是完成整个事务

+ mutex

  如果是可预测的插入行数，可以使用mutex对内存中的计数器做累加操作

#### 5.4 外键

修改外键的值, 首先需要给父表加共享锁。 select ……lock in share mode.

### :six: 分布式数据库

#### 6.1 CAP原则

+ Consistency （一致性）
+ Availability（可用性）
+ Partition-tolerance （分区容错性）

只能同时满足其中的两项。

#### 6.2 BASE理论

+ Basically-Available (基本可用)
+ Soft-state (软状态)
+ Eventually Consitent (最终一致性)

#### 6.3 分布式事务强一致性

#####  1. 二阶段提交协议

 **[XA协议-事务管理者/资源管理者]**

1. 准备流程：事务管理者向发起准备指令，询问资源管理者预提交是否成功；

2. 提交流程：如果所有的资源管理者都回复预提交成功，则正式提交命令。

缺点：

1.**同步阻塞问题**。执行过程中，所有参与节点都是事务阻塞型的。
当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。

2.**单点故障**。由于协调者的重要性，一旦协调者发生故障。
参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）

3.**数据不一致**。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。
而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。

#####  2. 三阶段提交协议

在二阶段的基础上增加`超时机制`，并且把两阶段提交协议的第一个阶段拆分成了两步：询问，然后再锁资源，最后真正提交。

`准备阶段` —`预提交阶段` — `提交阶段`

在2PC中，只有协调者拥有超时机制，即如果在一定时间内没有收到参与者的消息则默认失败。

在3PC中，只要超时无响应，则默认为失败。则调用者会向参与者发起中断指令，参与者接收到指令以后使用undo log 回滚。

>  在doCommit阶段[第三阶段]，如果参与者无法及时接收到来自协调者的doCommit或者abort请求时，会在等待超时之后，会继续进行事务的提交。
>
> 如果由于网络的原因，某个参与者没有接收到协调者发送的abort命令，则在超时等待以后会commit.该操作也会造成数据不一致的问题。

#### 6.4 最终一致性解决方案

##### TCC模式

- Try 阶段主要是对业务系统做检测及资源预留
- Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。
- Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。

spring中使用`@compensable` 可以完成try\confirm\cancel的调用。

##### 消息队列

`正反向消息机制` + `定时任务`

> 基本思路是将本地事务和生产者的消息发送放在一个事务中，保证本地操作和消息发送要么两者都成功或者都失败。下游应用向消息系统订阅该消息，收到消息后执行相应操作。

RocketMQ首先会发送`预执行消息` 到MQ，然后进行本地事务，如果本地事务的执行结果是`commit`,则正式投递MQ消息，如果本地事务`rollback`，则删除之前发送的预执行消息。



#### 6.5 幂等性

1. 创建唯一索引，防止插入重复的数据；
2. 分库分表的情况下，唯一索引会失效，所以需要在先查询一次是数据库，然后再判断约束的资源是否存在。并发的场景下可以使用分布式锁。
3. 状态机机制。

#### 6.5 主从复制、读写分离

主从复制方式： 是使用两个或两个以上相同的数据库，将一个数据库当做**主数据库**，而另一个数据库当做**从数据库。**在**主数据库**中进行相应操作时，**从数据库**记录下所有主数据库的操作，使其二者一模一样。 有**同步复制/异步复制/半同步复制**三种方式。

读写分离： 当**主数据库**进行对数据的增删改也就是写操作时，将查询的任务交给**从数据库** 。

 ###### 6.2 集群

如果说主从复制是各司其职的话，那么集群就是一群同样的个体做着同样的事情。 

###### 4.3 哨兵模式

 里面存储的是自己本身的信息，主服务器的信息，从服务器的信息。 用一个哨兵或者是多个哨兵来监视主服务器是否在正常运行，如果有问题，则找到一个合适的从服务器来代替它。

###### 4.4 非关系型数据库

 所以面对大量的数据读写，非关系型数据库相比较于关系型数据库有着巨大的优势。 key-value存储方式，数据之间没有关联，可扩展性高。

**Redis** 数据存储在内存中，可用来做缓存。需要持久化的数据就将其存入硬盘，不需要持久化的数据，可以进行短暂的存储，提高访问速度。 

###### 4.5 事务

1. ACID特性

>

2. 事务的隔离级别
   1. 

### :seven:日志

#### 7.1 重做日志

+ redo log  事务的持久性

+ undo log     作用： 回滚/mvcc

  undo log也会产生redo log

  undo log页可以重用

#### 7.2 二进制日志

#### 7.3 慢查询日志

#### 7.4 错误日志