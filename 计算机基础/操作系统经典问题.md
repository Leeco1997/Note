## 操作系统经典问题

[TOC]

### 一、进程和线程

#### 1. 内核态与用户态

这是计算机的两种运行状态。

**内核态：**操作系统处于内核态，它拥有访问**所有的硬件**的权限，可以使用特权指令。

:arrow_down_small: 作用

	1. 负责进程、线程的调度
 	2. 负责存储器的管理，内存地址到物理地址的转换
 	3. 中断（外中断、异常、陷入）

**用户态：**其他的软件运行在用户态上，只能使用**非特权指令**，操作内存、IO、设置时钟的一些指令是被被禁止的。**嵌入式系统、Java的操作系统**没有内核态。

`trap` 命令可以使得`用户态->内核态`.

> :grey_question:  什么时候会发生状态切换？如何切换？
>
> 1. 系统调用 （read/write)
> 2. 外部中断 (当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号。硬盘读写结束)
> 3. 异常 （发生了某些事先不可知的异常，会切换到处理此异常的内核相关程序中）

#### 2. 什么是系统调用

我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！

> 如果一个进程正在用户态中运行一个用户程序，并且需要一个系统服务，比如从一个文件读数据，那么它就必须执行一个陷阱或系统调用指令，将控制转移到操作系统。操作系统接着通过参数检查，找出所需要的调用进程。然后，它执行系统调用，并把控制返回给在系统调用后面跟随着的指令。在某种意义上，进行系统调用就像进行一个特殊的过程调用，但是**只有系统调用可以进入内核**，而过程调用则不能。

##### :zap: 计算机是如何运行程序的？

![image-20200720145629573](https://raw.githubusercontent.com/Leeco1997/images/master/img/20200720145654.png)



#### 3. 进程与线程

进程是**资源分配的单位**,本质上就是指的一个运行的程序,一个进程可以看作是一个程序的实例。

进程可以用来管理内存、IO、加载指令。

线程是**独立调度的单位**，一个进程中包含多个线程，如果从jvm中的角度来看，堆、元空间的数据是是多个线程共享的，程序计数器、本地方法栈、虚拟机栈的数据是每个线程私有的。

**区别**

1. **创建、切换、销毁**进程的开销更大；
2. 线程间可以读写同一个进程间的信息，而进程之间的通信需要借助于**IPC** ;

**进程的状态**：

1)运行态（该时刻进程实际占用CPU）。
2)就绪态（可运行，但因为其他进程正在运行而暂时停止）。
3)阻塞态（除非某种外部事件发生，否则进程不能运行）。

![image-20200704164449056](https://raw.githubusercontent.com/Leeco1997/images/master/img/pid-status.jpg)

#### 4. 进程间的通信方式

   同一台计算机之间的进程通信方式 — **IPC**

1. **管道/匿名管道(Pipes)** ：用于具有亲缘关系的**父子进程**间或者**兄弟进程**之间的通信。

2. **有名管道(Names Pipes)** : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。

3. **信号(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；

4. **消息队列(Message Queuing)** ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。**消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺。**

5. **信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。

   > **Semaphore信号量内部维护了一个计数器，其值为可以访问的共享资源的个数。一个线程要访问共享资源，先获得信号量，如果信号量的计数器值大于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。**

6. **共享内存(Shared memory)** ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依

9. 靠某种**同步操作**，如**互斥锁**和信号量等。可以说这是最有用的进程间通信方式。

10. **套接字(Sockets)** : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

#### 5. 并发与并行

`windows`的最小CPU分配是`15ms`

并发指的是**宏观上在同一时间可以执行多个程序**,微观上其实是串行的；

并行指的是**同一时刻可以运行多个指令**，比如多核处理器。

一般情况下，线程数是大于core数目的，所以程序运行中既有并行也有并发。

> **并发：** 同一时刻应对（deal with）多件事情；
>
> **并行：**同一时刻动手做（doing）多件事情。

#### 6. 线程间的通信方式

1. **互斥量（mutex）**例如synchronized 关键词和各种 Lock ；
2. **信号量(Semaphores) ：**它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
3. **事件(Event)** :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操

####  7. 进程的调度算法

- **先到先服务(FCFS)调度算法** : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
- **短作业优先(SJF)的调度算法** : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
- **时间片轮转调度算法** : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。
- **多级反馈队列调度算法** ：前面介绍的几种进程调度的算法都有一定的局限性。如**短进程优先的调度算法，仅照顾了短进程而忽略了长进程** 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前**被公认的一种较好的进程调度算法**，UNIX 操作系统采取的便是这种调度算法。
- **优先级调度** ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。

> **多级反馈队列调度算法：**
>
> 1. 为每个队列设置优先级，并分配时间片，1.2.4.8.16……
> 2. 随着优先级的降低，时间片也增加。在高优先级使用FCFS低优先级使用RR策略；
> 3. 若`Q1`中没有需要处理的进程了，则调度`Q2`的进程；
> 4. 若`Q1`的任务没有处理结束，则插入`Q2`的尾巴。

### 二、 内存管理

#### 1. 操作系统的内存管理机制了解吗？内存管理有哪几种方式?

1. **块式管理** ： 远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。
2. **页式管理** ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过**页表对应逻辑地址和物理地址**。
3. **段式管理** ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过**段表**对应逻辑地址和物理地址。

4. **段页式管理机制**结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 **段页式管理机制** 中段与段之间以及段的内部的都是离散的。

**页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。**

**页和段都是离散存储中，但是每个页和每个段内的内存是连续的。**

#### 2. 快表与多级页表

**快表**

解决物理地址与虚拟地址之间的转换速度问题。

实质上就是使用的**高速缓存Cache**,快表就是作为页表的Cache.

每次使用的时候，先去块表中找，找不到的情况下就去页表。

**多级页表**

#### 3.  虚拟内存

物理内存扩充为更大的逻辑内存。

每个程序拥有自己的地址空间，空间被分为多个页，每一页都有一个连续的地址范围，**这些页被映射到物理内存**，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。

#### 4. 页面置换算法

- **【理论】OPT 页面置换算法（最佳页面置换算法）** ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。
- **FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）** : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。
- **LRU （Least Currently Used）页面置换算法（最近最久未使用页面置换算法）** ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。
- **LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）** : 该置换算法选择在之前时期使用最少的页面作为淘汰页。



